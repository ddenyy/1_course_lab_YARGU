#include "Header.h"

struct Train
{
	string destination_point = "";
	int start_time = 0;
	int serial_number = 0;
};

// узел дерева AVL
class AVLNode {
public:
	vector<Train> trains;
	AVLNode* left;
	AVLNode* right;
	// глубина
	int depth;
};

// max int int
int max(int a, int b)
{
	if (a > b)
	{
		return a;
	}
	else {
		return b;
	}
}

// ф-ция получения глубины элемента
int depth(AVLNode* elem)
{
	if (elem == NULL)
	{
		return 0;
	}
	return elem->depth;
}

// создание нового узла
AVLNode* newNode(Train train)
{
	AVLNode* node = new AVLNode();
	node->trains.push_back(train);
	node->left = NULL;
	node->right = NULL;
	node->depth = 1; // добавили как лист в дерево
	return node;
}

// поворот вправо поддерева с корнем
AVLNode* rightRotate(AVLNode* y)
{
	AVLNode* x = y->left;
	AVLNode* T2 = x->right;

	// вращение
	x->right = y;
	y->left = T2;


	y->depth = max(depth(y->left), depth(y->right)) + 1;
	x->depth = max(depth(x->left), depth(x->right)) + 1;

	// x стал корнем
	return x;
}

// поворот дерева с корнем х
AVLNode* leftRotate(AVLNode* x)
{
	AVLNode* y = x->right;
	AVLNode* T2 = y->left;

	// вращение влево
	y->left = x;
	x->right = T2;

	x->depth = max(depth(x->left), depth(x->right)) + 1;
	y->depth = max(depth(y->left), depth(y->right)) + 1;

	return y;
}

int getBalance(AVLNode* elem)
{
	if (elem == NULL)
	{
		return 0;
	}
	else
	{
		return depth(elem->left) - depth(elem->right);
	}
}

// операции добавления (вставка для узла)
AVLNode* insert(AVLNode* node, Train train)
{
	if (node == NULL)
	{
		return newNode(train);
	}

	if (train.destination_point < node->trains[0].destination_point) // уход влево
	{
		node->left = insert(node->left, train);
	}
	else if (train.destination_point > node->trains[0].destination_point) // уход вправо
	{
		node->right = insert(node->right, train);
	}
	else // равные значения с узлом
	{
		node->trains.push_back(train);
		return node;
	}

	// обновили глубину текущего узла
	node->depth = 1 + max(depth(node->left), depth(node->right));

	int balance = getBalance(node);

	// поворот вправо и вправо
	if (balance < -1 && train.destination_point > node->right->trains[0].destination_point)
	{
		return leftRotate(node);
	}
	// поворот лево и лево
	if (balance > 1 && train.destination_point < node->left->trains[0].destination_point)
	{
		return rightRotate(node);
	}

	// поворот лево право
	if (balance > 1 && train.destination_point > node->left->trains[0].destination_point)
	{
		node->left = leftRotate(node->left);
		return rightRotate(node);
	}

	// право лево
	if (balance < -1 && train.destination_point < node->right->trains[0].destination_point)
	{
		node->right = rightRotate(node->right);
		return leftRotate(node);
	}

	return node;
}

AVLNode* minValueNode(AVLNode* node)
{
	AVLNode* current = node;
	// найти крайний левый лист
	while (current->left != NULL)
	{
		current = current->left;
	}
	return current;
}

AVLNode* deleteNode(AVLNode* root, Train train)
{
	if (root == NULL)
	{
		return root;
	}

	if (train.destination_point < root->trains[0].destination_point)
	{
		root->left = deleteNode(root->left, train);
	}
	else if (train.destination_point > root->trains[0].destination_point)
	{
		root->right = deleteNode(root->right, train);
	}
	else
	{
		// узел только с одним дочерним элементом или без дочернего эл-та
		if ((root->left == NULL) || (root->right == NULL))
		{
			AVLNode* temp = root->left != NULL ? root->left : root->right;
			if (temp == NULL)
			{
				temp = root;
				root = NULL;
			}
			else
			{
				*root = *temp;
			}
		}
		else
		{
			AVLNode* temp = minValueNode(root->right);
			root->trains = temp->trains;
			root->right = deleteNode(root->right, temp->trains[0]);
		}
	}

	if (root == NULL)
	{
		return root;
	}

	// depth
	root->depth = max(depth(root->left), depth(root->right)) + 1;
	int balance = getBalance(root);

	// повернем дерево если оно не является сбалансированным

	// лево лево
	if (balance > 1 && getBalance(root->left) >= 0)
	{
		return rightRotate(root);
	}
	// лево право
	if (balance > 1 && (getBalance(root->left) < 0))
	{
		root->left = leftRotate(root->left);
		return rightRotate(root);
	}

	// право право
	if (balance < -1 && getBalance(root->right) <= 0)
	{
		return leftRotate(root);
	}

	// право лево
	if (balance < -1 && getBalance(root->right) > 0)
	{
		root->right = rightRotate(root->right);
		return leftRotate(root);
	}

	return root;
}


void find_train__time(AVLNode* root, int find_time)
{

}


void show(AVLNode* Elem, int level)
{
	if (Elem->left != NULL)
	{
		show(Elem->left, level + 1);
	}
	for (int i = 0; i < level; i++)
	{
		cout << "      ";
	}
	
	for (auto i : Elem->trains) cout << i.serial_number << ' ';
	/*cout << Elem->train.serial_number << '\n';*/

	if (Elem->right != NULL)
	{
		show(Elem->right, level + 1);
	}
}




template<class tmp>
tmp abs(tmp a)
{
	if (a > 0)
		return a;
	else
		return -a;
}


int main()
{
	Train first;
	first.destination_point = "A";
	first.serial_number = 123123;
	first.start_time = 0;
	Train second;
	second.destination_point = "B";
	second.serial_number = 321321;
	second.start_time = 2;
	Train third;
	third.destination_point = "B";
	third.serial_number = 3939393;
	third.start_time = 3;
	Train four;
	four.destination_point = "B";
	four.serial_number = 282828;
	four.start_time = 4;


	AVLNode* Root = NULL;
	Root = insert(Root, first);
	Root = insert(Root, second);
	Root = insert(Root, third);
	Root = insert(Root, four);

	//deleteNode(Root, first);
	/*Root = insert(Root, 11);
	Root = insert(Root, 17);
	Root = insert(Root, 4);
	Root = insert(Root, 1);
	Root = insert(Root, 2);
	Root = insert(Root, 3);
	Root = insert(Root, 6);
	Root = insert(Root, 7);
	Root = insert(Root, 8);*/

	show(Root, 0);

}
